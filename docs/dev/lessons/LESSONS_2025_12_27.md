# Lessons Learned - December 27, 2025

## Session Focus: Performance Optimization for Swap & Pool Pages

### Problem Statement
Swap and Pool pages took ~2 seconds to load due to sequential API calls for contract data.

---

## Key Discoveries

### 1. Sequential vs Parallel API Calls

**Before (SLOW):**
```typescript
// Each call waits for the previous one to complete
for (const pairId of pairIds) {
  const info = await queryContract(`getPairInfoPair${pairId}`, ...);  // BLOCKS!
}
// With 2 pairs: 3 sequential calls × ~400ms = ~1200ms
```

**After (FAST):**
```typescript
// All calls execute simultaneously
const pairPromises = pairIds.map(async (pairId) => {
  return await queryContract(`getPairInfoPair${pairId}`, ...);
});
const results = await Promise.all(pairPromises);
// With 2 pairs: 1 parallel batch = ~400ms
```

**Lesson:** Always use `Promise.all()` when multiple independent API calls are needed.

---

### 2. Redundant Data Fetching

**Discovery:** The `getPairInfoPairX` contract call already returns reserves:
```
[0] tokenA
[1] tokenB
[2] tokenAIsKlv
[3] tokenBIsKlv
[4] reserveA      ← Already there!
[5] reserveB      ← Already there!
[6] feePercent
[7] isActive
```

But then `usePairReserves` called `getPairReserves()` which fetches the SAME data again!

**Solution:** Add `initialReserves` to the `TradingPair` type:
```typescript
interface TradingPair {
  // ... existing fields ...
  initialReserves?: {
    base: number;
    quote: number;
    fetchedAt: number;
  };
}
```

**Lesson:** When fetching structured data, check if you're throwing away useful fields that could eliminate later API calls.

---

### 3. SwapPriceChart NaN Bug

**Cause:** Division by zero in scale functions:
```typescript
// When prices.length === 1:
const xScale = (index / (prices.length - 1));  // 0/0 = NaN

// When all prices are equal:
const yScale = ((price - min) / (max - min));  // x/0 = NaN
```

**Fix:**
```typescript
const xScale = (index: number) => {
  if (prices.length <= 1) return padding.left + chartWidth / 2;  // Center single point
  return padding.left + (index / (prices.length - 1)) * chartWidth;
};

const yDenominator = paddedMax - paddedMin || 1;  // Prevent /0
```

**Lesson:** Always guard against division by zero in UI math, especially for charts with dynamic data.

---

### 4. "Failed to fetch" Error Context

**Problem:** Generic "Failed to fetch" gives no debugging context.

**Solution:** Wrap fetch with context:
```typescript
try {
  const response = await fetch(url, options);
} catch (error) {
  if (error.message === 'Failed to fetch') {
    throw new Error(`Network error: Unable to reach ${url}. Check CORS/connectivity.`);
  }
  throw error;
}
```

**Lesson:** Always add context to generic errors for easier debugging.

---

## Files Modified

| File | Change |
|------|--------|
| `src/types/tradingPairs.ts` | Added `initialReserves` field |
| `src/app/swap/hooks/useTradingPairs.ts` | Parallel fetching + stores reserves |
| `src/app/swap/hooks/usePairReserves.ts` | Uses cached reserves |
| `src/app/swap/hooks/useLiquidityProvider.ts` | Parallel LP queries |
| `src/app/swap/components/SwapPriceChart.tsx` | NaN fix |
| `src/app/swap/page.tsx` | Uses cached reserves |
| `src/config/app.ts` | Version 1.17.0 |
| `docs/CHANGELOG.md` | Added v1.17.0 entry |

---

## Performance Results

| Metric | Before | After | Improvement |
|--------|--------|-------|-------------|
| Initial Load | ~2000ms | ~400-600ms | **3-4x faster** |
| Pair Switch | ~600ms | instant | **∞** |
| LP Position | ~1500ms | ~500ms | **3x faster** |

---

## Future Optimization Ideas

1. **Background Refresh** - Silently refresh reserves every 30s without blocking UI
2. **SWR/React Query** - Use proper caching library with stale-while-revalidate
3. **WebSocket** - Real-time reserve updates instead of polling
4. **Service Worker** - Cache API responses for offline support

---

## Related Documentation

- `docs/dev/PERFORMANCE_AUDIT_SWAP_POOL.md` - Full audit details
- `docs/CHANGELOG.md` - v1.17.0 entry
